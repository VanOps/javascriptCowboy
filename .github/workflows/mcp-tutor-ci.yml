name: CI - MCP Tutor

# Se activa cuando hay cambios en mcp-tutor o en el workflow mismo
on:
  push:
    branches: [main, develop]
    paths:
      - "tutor/mcp-tutor/**"
      - ".github/workflows/mcp-tutor-ci.yml"
  pull_request:
    branches: [main, develop]
    paths:
      - "tutor/mcp-tutor/**"
      - ".github/workflows/mcp-tutor-ci.yml"

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üê≥ Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üî® Build imagen MCP Tutor
        working-directory: tutor/mcp-tutor
        run: |
          docker build -t mcp-tutor:ci .

      - name: üöÄ Levantar servicio
        working-directory: tutor/mcp-tutor
        env:
          # Token fake para testing (el error por DNS/token es esperado, solo validamos que la app arranca)
          GITHUB_TOKEN: ${{ secrets.MCP_GITHUB_TOKEN || 'ghp_fake_token_for_ci_testing' }}
        run: |
          # Crear .env temporal para CI
          echo "GITHUB_TOKEN=${GITHUB_TOKEN}" > .env

          # Levantar con docker-compose
          docker compose up -d

          # Esperar a que la app est√© lista (max 60s)
          echo "‚è≥ Esperando a que MCP Tutor est√© listo..."
          for i in {1..30}; do
            if curl -sf http://localhost:3002 > /dev/null 2>&1; then
              echo "‚úÖ MCP Tutor respondiendo"
              break
            fi
            echo "   Intento $i/30..."
            sleep 2
          done

      - name: üß™ Pruebas de validaci√≥n
        run: |
          # 1. Verificar que la p√°gina principal carga
          echo "üîç Test 1: P√°gina principal"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3002)
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Fallo: p√°gina principal devolvi√≥ $HTTP_CODE"
            exit 1
          fi
          echo "‚úÖ P√°gina principal OK (HTTP 200)"

          # 2. Verificar que el API route existe (puede fallar por falta de token, pero debe responder)
          echo "üîç Test 2: API endpoint existe"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d '{"mensajes":[],"modulo":"general"}' \
            http://localhost:3002/api/chat)
          # Aceptamos 500 (error de token/DNS) o 200 - lo importante es que la ruta existe
          if [ "$HTTP_CODE" != "500" ] && [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Fallo: API devolvi√≥ c√≥digo inesperado $HTTP_CODE"
            exit 1
          fi
          echo "‚úÖ API route existe (HTTP $HTTP_CODE)"

          # 3. Verificar que los assets est√°ticos cargan
          echo "üîç Test 3: Assets Next.js"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3002/_next/static/css/app/layout.css 2>/dev/null || echo "404")
          # Los assets pueden estar en diferentes rutas seg√∫n el build, 404 es aceptable
          echo "   CSS assets: HTTP $HTTP_CODE (OK si 200 o 404)"

          # 4. Verificar estructura HTML b√°sica
          echo "üîç Test 4: HTML contiene elementos esperados"
          HTML=$(curl -s http://localhost:3002)
          if ! echo "$HTML" | grep -q "MCP Tutor"; then
            echo "‚ùå Fallo: no se encontr√≥ 'MCP Tutor' en el HTML"
            exit 1
          fi
          if ! echo "$HTML" | grep -q "JavaScript Cowboy"; then
            echo "‚ùå Fallo: no se encontr√≥ 'JavaScript Cowboy' en el HTML"
            exit 1
          fi
          echo "‚úÖ HTML contiene elementos esperados"

      - name: üìã Mostrar logs en caso de fallo
        if: failure()
        working-directory: tutor/mcp-tutor
        run: |
          echo "üîç Logs del contenedor MCP Tutor:"
          docker compose logs --tail=100

      - name: üßπ Cleanup
        if: always()
        working-directory: tutor/mcp-tutor
        run: |
          docker compose down -v
          rm -f .env
