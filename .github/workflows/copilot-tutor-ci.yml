name: CI - Copilot Tutor

# Se activa cuando hay cambios en copilot-tutor o en el workflow mismo
on:
  push:
    branches: [main, develop]
    paths:
      - 'tutor/copilot-tutor/**'
      - '.github/workflows/copilot-tutor-ci.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'tutor/copilot-tutor/**'
      - '.github/workflows/copilot-tutor-ci.yml'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ³ Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”¨ Build imagen Copilot Tutor
        working-directory: tutor/copilot-tutor
        run: |
          docker build -t copilot-tutor:ci .

      - name: ğŸš€ Levantar servicio
        working-directory: tutor/copilot-tutor
        env:
          # Token fake para testing (el 403 es esperado, solo validamos que la app arranca)
          GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN || 'ghp_fake_token_for_ci_testing' }}
        run: |
          # Crear .env temporal para CI
          echo "GITHUB_TOKEN=${GITHUB_TOKEN}" > .env
          
          # Levantar con docker-compose
          docker compose up -d
          
          # Esperar a que la app estÃ© lista (max 60s)
          echo "â³ Esperando a que Copilot Tutor estÃ© listo..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000 > /dev/null 2>&1; then
              echo "âœ… Copilot Tutor respondiendo"
              break
            fi
            echo "   Intento $i/30..."
            sleep 2
          done

      - name: ğŸ§ª Pruebas de validaciÃ³n
        run: |
          # 1. Verificar que la pÃ¡gina principal carga
          echo "ğŸ” Test 1: PÃ¡gina principal"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000)
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Fallo: pÃ¡gina principal devolviÃ³ $HTTP_CODE"
            exit 1
          fi
          echo "âœ… PÃ¡gina principal OK (HTTP 200)"
          
          # 2. Verificar que el API route existe (puede fallar por falta de token, pero debe responder)
          echo "ğŸ” Test 2: API endpoint existe"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d '{"mensajes":[],"modulo":"general"}' \
            http://localhost:3000/api/chat)
          # Aceptamos 500 (error de token) o 200 - lo importante es que la ruta existe
          if [ "$HTTP_CODE" != "500" ] && [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Fallo: API devolviÃ³ cÃ³digo inesperado $HTTP_CODE"
            exit 1
          fi
          echo "âœ… API route existe (HTTP $HTTP_CODE)"
          
          # 3. Verificar que los assets estÃ¡ticos cargan
          echo "ğŸ” Test 3: Assets Next.js"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/_next/static/chunks/webpack-*.js 2>/dev/null || echo "404")
          # Los chunks de webpack deben existir
          if [[ ! "$HTTP_CODE" =~ ^(200|304)$ ]]; then
            echo "âš ï¸  Advertencia: Assets pueden no estar cargando correctamente"
          else
            echo "âœ… Assets Next.js OK"
          fi

      - name: ğŸ“Š Mostrar logs si falla
        if: failure()
        working-directory: tutor/copilot-tutor
        run: |
          echo "ğŸ“‹ Logs de Copilot Tutor:"
          docker compose logs

      - name: ğŸ§¹ Limpiar recursos
        if: always()
        working-directory: tutor/copilot-tutor
        run: |
          docker compose down -v
          rm -f .env
